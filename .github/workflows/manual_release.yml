name: Manual Release

on:
  workflow_dispatch:
    inputs:
      release_type:
        description: "Select the version segment to bump"
        required: true
        type: choice
        default: patch
        options:
          - patch
          - minor
          - major

permissions:
  contents: write

jobs:
  publish:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get latest git tag
        id: get_latest_tag
        run: |
          LATEST_TAG=$(git tag -l 'v*' --sort=-v:refname | head -n 1)
          if [ -z "$LATEST_TAG" ]; then
            LATEST_TAG="v0.0.0"
          fi
          echo "LATEST_TAG=$LATEST_TAG" >> $GITHUB_ENV

      - name: Set up Python 3.12
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install uv
        run: pip install uv

      - name: Bump project version
        id: bump
        env:
          RELEASE_TYPE: ${{ github.event.inputs.release_type }}
        run: |
          python <<'PY'
          import os
          import re
          from pathlib import Path

          release_type = os.environ.get("RELEASE_TYPE", "patch").lower()
          if release_type not in {"major", "minor", "patch"}:
              raise SystemExit(f"Unsupported release type: {release_type}")

          pyproject_path = Path("pyproject.toml")
          content = pyproject_path.read_text(encoding="utf-8")
          match = re.search(r'version\s*=\s*"(\d+)\.(\d+)\.(\d+)"', content)
          if not match:
              raise SystemExit("Unable to find version in pyproject.toml")

          major, minor, patch = map(int, match.groups())

          if release_type == "major":
              major += 1
              minor = 0
              patch = 0
          elif release_type == "minor":
              minor += 1
              patch = 0
          else:
              patch += 1

          new_version = f"{major}.{minor}.{patch}"
          updated = re.sub(
              r'version\s*=\s*"(\d+)\.(\d+)\.(\d+)"',
              f'version = "{new_version}"',
              content,
              count=1,
          )
          pyproject_path.write_text(updated, encoding="utf-8")

          previous_version = ".".join(match.groups())
          print(f"Bumped version: {previous_version} -> {new_version}")

          github_output = os.environ["GITHUB_OUTPUT"]
          with open(github_output, "a", encoding="utf-8") as fh:
              fh.write(f"new_version={new_version}\n")
          PY

      - name: Show version change
        run: git --no-pager diff pyproject.toml

      - name: Build distribution artifacts
        run: |
          rm -rf dist/
          uv build

      - name: Publish to PyPI
        env:
          PYPI_TOKEN: ${{ secrets.PYPI_API_TOKEN }}
        run: |
          if [ -z "$PYPI_TOKEN" ]; then
            echo "Missing PyPI token. Please set the PYPI_API_TOKEN secret." >&2
            exit 1
          fi
          uv publish --token "$PYPI_TOKEN"

      - name: Commit version bump
        env:
          NEW_VERSION: ${{ steps.bump.outputs.new_version }}
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git add pyproject.toml
          if git diff --cached --quiet; then
            echo "No changes to commit."
          else
            git commit -m "chore: release ${NEW_VERSION}"
          fi

      - name: Create tag
        env:
          NEW_VERSION: ${{ steps.bump.outputs.new_version }}
        run: |
          if git rev-parse "v${NEW_VERSION}" >/dev/null 2>&1; then
            echo "Tag v${NEW_VERSION} already exists." >&2
            exit 1
          fi
          git tag "v${NEW_VERSION}"

      - name: Push commit and tag
        env:
          NEW_VERSION: ${{ steps.bump.outputs.new_version }}
        run: |
          BRANCH="${GITHUB_REF_NAME:-main}"
          git push origin "HEAD:${BRANCH}"
          git push origin "v${NEW_VERSION}"

      - name: Get commit log for release notes
        id: get_commits
        env:
          NEW_VERSION: ${{ steps.bump.outputs.new_version }}
        run: |
          if [ "$LATEST_TAG" == "v0.0.0" ]; then
            COMMIT_LOG=$(git log --pretty=format:"- %h %s" HEAD)
          else
            COMMIT_LOG=$(git log --pretty=format:"- %h %s" ${LATEST_TAG}..HEAD)
          fi

          echo "$COMMIT_LOG" > commit_log.txt

          {
            echo 'COMMIT_LOG_CONTENT<<EOF'
            echo "$COMMIT_LOG"
            echo 'EOF'
          } >> $GITHUB_ENV

      - name: Generate release notes with Claude
        id: generate_notes
        continue-on-error: true
        uses: anthropics/claude-code-action@v1
        env:
          NEW_VERSION: ${{ steps.bump.outputs.new_version }}
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          prompt: |
            Generate professional release notes for version v${{ steps.bump.outputs.new_version }}.

            Here is the commit log since the last release (${{ env.LATEST_TAG }}):

            ```
            ${{ env.COMMIT_LOG_CONTENT }}
            ```

            Instructions:
            1. Analyze the commits and categorize them into:
               - **Features**: New functionality (commits with feat:, feature:, or add:)
               - **Bug Fixes**: Bug fixes (commits with fix:, bugfix:, or hotfix:)
               - **Improvements**: Enhancements, refactoring, performance (commits with improve:, refactor:, perf:, or chore:)
               - **Documentation**: Doc changes (commits with docs: or doc:)
               - **Other Changes**: Anything else noteworthy

            2. For each change, write a clear, user-friendly description

            3. If you find Jira ticket references (pattern like ABC-123), include links to:
               https://omelet.atlassian.net/browse/TICKET-ID

            4. Format the release notes in Markdown with:
               - A brief summary of what's in this release (1-2 sentences)
               - Categorized sections with bullet points
               - Skip empty categories

            Return the release notes as a single markdown string.

          claude_args: |
            --model claude-sonnet-4-5-20250929
            --max-turns 3
            --json-schema '{"type":"object","properties":{"release_notes":{"type":"string","description":"The formatted release notes in Markdown"}},"required":["release_notes"]}'

      - name: Create GitHub Release
        uses: actions/github-script@v6
        env:
          NEW_VERSION: ${{ steps.bump.outputs.new_version }}
          STRUCTURED_OUTPUT: ${{ steps.generate_notes.outputs.structured_output }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const tagName = `v${process.env.NEW_VERSION}`;

            // Get release notes from Claude's structured output
            const structuredOutput = process.env.STRUCTURED_OUTPUT;
            let releaseNotes = '';

            if (structuredOutput) {
              try {
                const parsed = JSON.parse(structuredOutput);
                releaseNotes = parsed.release_notes || '';
              } catch (e) {
                console.log('Failed to parse structured output:', e.message);
              }
            }

            // Fallback to commit log if Claude failed or returned empty
            if (!releaseNotes) {
              console.log('Using fallback release notes from commit log');
              try {
                releaseNotes = `## What's Changed\n\n${fs.readFileSync('commit_log.txt', 'utf8')}`;
              } catch (e) {
                releaseNotes = `Release ${tagName}`;
              }
            }

            await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: tagName,
              name: `Release ${tagName}`,
              body: releaseNotes,
              target_commitish: context.sha,
              draft: false,
              prerelease: false
            });

            console.log(`Created release ${tagName}`);

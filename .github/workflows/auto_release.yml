name: Release

on:
  push:
    branches:
      - main

# Prevent concurrent releases (race condition protection)
concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: write

jobs:
  release:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Extract version from pyproject.toml
        id: get_version
        run: |
          VERSION=$(python3 -c "import tomllib; print(tomllib.load(open('pyproject.toml', 'rb'))['project']['version'])" 2>/dev/null || grep -oP '(?<=version = ")[^"]*' pyproject.toml)
          if [ -z "$VERSION" ]; then
            echo "::error::Failed to extract version from pyproject.toml"
            exit 1
          fi
          echo "VERSION=$VERSION" >> $GITHUB_ENV

      - name: Get latest git tag
        id: get_latest_tag
        run: |
          LATEST_TAG=$(git tag -l 'v*' --sort=-v:refname | head -n 1)
          if [ -z "$LATEST_TAG" ]; then
            LATEST_TAG="v0.0.0"
          fi
          LATEST_VERSION=${LATEST_TAG#v}
          echo "LATEST_TAG=$LATEST_TAG" >> $GITHUB_ENV
          echo "LATEST_VERSION=$LATEST_VERSION" >> $GITHUB_ENV

      - name: Compare versions
        id: compare_versions
        run: |
          echo "Comparing versions: VERSION=$VERSION, LATEST_VERSION=$LATEST_VERSION"
          highest_version=$(
            printf '%s\n' "$LATEST_VERSION" "$VERSION" | sort -V | tail -n 1
          )
          if [ "$VERSION" = "$highest_version" ] && [ "$VERSION" != "$LATEST_VERSION" ]; then
            echo "NEW_VERSION=$VERSION"
            echo "NEW_VERSION=$VERSION" >> $GITHUB_ENV
          else
            echo "No new version to release."
            echo "NEW_VERSION=" >> $GITHUB_ENV
          fi

      - name: Get commit log for release notes
        if: env.NEW_VERSION != ''
        id: get_commits
        run: |
          if [ "$LATEST_TAG" == "v0.0.0" ]; then
            COMMIT_LOG=$(git log --pretty=format:"- %h %s" HEAD)
          else
            COMMIT_LOG=$(git log --pretty=format:"- %h %s" ${LATEST_TAG}..HEAD)
          fi

          echo "$COMMIT_LOG" > commit_log.txt

          {
            echo 'COMMIT_LOG_CONTENT<<EOF'
            echo "$COMMIT_LOG"
            echo 'EOF'
          } >> $GITHUB_ENV

      - name: Generate release notes with Claude
        if: env.NEW_VERSION != ''
        id: generate_notes
        continue-on-error: true
        uses: anthropics/claude-code-action@v1
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          prompt: |
            Generate professional release notes for version v${{ env.NEW_VERSION }}.

            Here is the commit log since the last release (v${{ env.LATEST_VERSION }}):

            ```
            ${{ env.COMMIT_LOG_CONTENT }}
            ```

            Instructions:
            1. Analyze the commits and categorize them into:
               - **Features**: New functionality (commits with feat:, feature:, or add:)
               - **Bug Fixes**: Bug fixes (commits with fix:, bugfix:, or hotfix:)
               - **Improvements**: Enhancements, refactoring, performance (commits with improve:, refactor:, perf:, or chore:)
               - **Documentation**: Doc changes (commits with docs: or doc:)
               - **Other Changes**: Anything else noteworthy

            2. For each change, write a clear, user-friendly description

            3. If you find Jira ticket references (pattern like ABC-123), include links to:
               https://omelet.atlassian.net/browse/TICKET-ID

            4. Format the release notes in Markdown with:
               - A brief summary of what's in this release (1-2 sentences)
               - Categorized sections with bullet points
               - Skip empty categories

            Return the release notes as a single markdown string.

          claude_args: |
            --model claude-sonnet-4-5-20250929
            --max-turns 3
            --json-schema '{"type":"object","properties":{"release_notes":{"type":"string","description":"The formatted release notes in Markdown"}},"required":["release_notes"]}'

      - name: Create new tag
        if: env.NEW_VERSION != ''
        env:
          NEW_VERSION: ${{ env.NEW_VERSION }}
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          git tag -a "v${NEW_VERSION}" -m "Release version ${NEW_VERSION}"
          git push origin "v${NEW_VERSION}"

      - name: Create GitHub Release
        if: env.NEW_VERSION != ''
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const tagName = `v${process.env.NEW_VERSION}`;

            // Get release notes from Claude's structured output
            const structuredOutput = process.env.STRUCTURED_OUTPUT;
            let releaseNotes = '';

            if (structuredOutput) {
              try {
                const parsed = JSON.parse(structuredOutput);
                releaseNotes = parsed.release_notes || '';
              } catch (e) {
                console.log('Failed to parse structured output:', e.message);
              }
            }

            // Fallback to commit log if Claude failed or returned empty
            if (!releaseNotes) {
              console.log('Using fallback release notes from commit log');
              try {
                releaseNotes = `## What's Changed\n\n${fs.readFileSync('commit_log.txt', 'utf8')}`;
              } catch (e) {
                releaseNotes = `Release ${tagName}`;
              }
            }

            await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: tagName,
              name: `Release ${tagName}`,
              body: releaseNotes,
              target_commitish: context.sha,
              draft: false,
              prerelease: false
            });

            console.log(`Created release ${tagName}`);
        env:
          STRUCTURED_OUTPUT: ${{ steps.generate_notes.outputs.structured_output }}
